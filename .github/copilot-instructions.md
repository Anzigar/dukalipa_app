{
  "File & Folder Structure": {
    "scope": "markdown",
    "prefix": "structure-guide",
    "body": [
      "# File & Folder Structure",
      "",
      "Adopt a consistent, maintainable layout recognized by major tech companies (Google) clean layout architecture:",
      "",
      " - Group related modules by feature, naming directories in lowercase_with_underscores.",
      " - Keep config files (e.g., `.env`) separate from core logic.",
      " - Place all Docker-related files in a dedicated `docker/` or root-level folder named `Dockerfile` or `Dockerfile.<lang>` as needed.",
      " - Use meaningful names for components, controllers, models, and route to improve readability.",
      "convert file into packages if exceed 150 lines of code "
      " - Maintain a `tests/` or equivalent directory for each language (Python, JS, Go,React,Angular etc.).",
      " - Document directory contents in a `README.md` or `ARCHITECTURE.md` to help new contributors."
    ]
  },
  "Docker Best Practices": {
    "scope": "markdown",
    "prefix": "docker-guide",
    "body": [
      "# Docker Best Practices",
      "",
      "Building on standards from Google Cloud and industry best practices:",
      "",
      "## **Base Images**",
      "",
      "- Use minimal base images for security and faster builds:",
      "  - Alpine Linux for extremely small images when compatible",
      "  - Distro-specific slim variants (e.g., python:3.9-slim, golang:1.18-alpine)",
      "  - Google's Distroless images for production deployments",
      "- Pin specific versions with SHA digests for immutability (e.g., `python:3.9-slim@sha256:...`)",
      "- Regularly update base images to include security patches",
      "",
      "## **Dockerfile Structure**",
      "",
      "- Keep Dockerfiles short and readable",
      "- Use multi-stage builds to minimize final image size:",
      "  - Build stage for compilation and dependencies",
      "  - Final stage with only runtime requirements",
      "- Group related commands in a single RUN instruction to reduce layers",
      "- Order instructions from least to most frequently changing",
      "- Use ARG for build-time variables and ENV for runtime variables",
      "",
      "## **Language Specific Practices**",
      "",
      "### **Python**",
      "",
      "- Use virtual environments (venv) during build",
      "- Pre-compile Python bytecode to improve startup times",
      "- Use pip with requirements.txt or Poetry with pinned dependencies",
      "- Install only production dependencies in final image",
      "- Consider using pypy for performance-critical applications",
      "",
      "### **Django**",
      "",
      "- Set `DEBUG=False` in production containers",
      "- Use environment variables for sensitive settings (SECRET_KEY, database credentials)",
      "- Pre-collect static files during build with `collectstatic`",
      "- Run migrations in an init container or startup script, not in Dockerfile",
      "- Configure proper Gunicorn/uWSGI settings for production",
      "- Implement health checks specific to Django application status",
      "- Set appropriate file permissions for media and static directories",
      "",
      "### **Go**",
      "",
      "- Leverage Go's static compilation for minimal runtime dependencies",
      "- Build with CGO_ENABLED=0 for truly static binaries",
      "- Use multi-stage builds to separate build tools from runtime",
      "- Consider scratch or distroless images for production",
      "- Use Go modules with vendored dependencies for reproducible builds",
      "",
      "### **JavaScript**",
      "",
      "- Use multi-stage builds for frontend applications",
      "- Build static assets in build stage, serve from minimal web server",
      "- For React/Angular apps, use nginx as lightweight server",
      "- Lock npm/yarn dependencies with package-lock.json or yarn.lock",
      "- Run with non-root users, especially for Express applications",
      "",
      "## **Security**",
      "",
      "- Run containers as non-root users",
      "- Remove unnecessary tools and shell access from production images",
      "- Scan images for vulnerabilities before deployment",
      "- Use read-only file systems where possible",
      "- Never include secrets in Docker images (use secret management solutions)",
      "",
      "## **Efficiency**",
      "",
      "- Use `.dockerignore` to exclude logs, temp files, Git directories, etc.",
      "- Leverage build cache efficiently by ordering instructions properly",
      "- Minimize the number of layers in your images",
      "- Clean up package manager caches in the same RUN step",
      "- Copy only necessary files for each build stage",
      "",
      "## **Container Management**",
      "",
      "- Implement a consistent image tagging strategy (e.g., semver + commit hash)",
      "- Set resource limits (memory, CPU) for containers",
      "- Use Docker Compose for development environments",
      "- Implement proper health checks for production containers",
      "- Configure logging appropriately with structured log formats",
      "",
      "## **CI/CD Integration**",
      "",
      "- Build and test images in CI/CD pipelines",
      "- Cache dependencies between builds when possible",
      "- Implement automated vulnerability scanning",
      "- Sign container images for trust verification",
      "- Integrate with Google Container Registry or Artifact Registry"
    ]
  },
  "Testing Approaches": {
    "scope": "markdown",
    "prefix": "test-guide",
    "body": [
      "# Testing Approaches",
      "",
      "A robust test strategy aligns with Google's engineering practices:",
      "",
      "## **Test Pyramid Architecture**",
      "",
      "- **Small Tests (Unit)**: Fast, focused tests that validate individual components in isolation.",
      "- **Medium Tests (Integration)**: Validate interactions between components/services.",
      "- **Large Tests (End-to-End)**: Validate complete user journeys across the entire system.",
      "",
      "## **Testing Best Practices**",
      "",
      "- Maintain 80%+ code coverage for critical business logic.",
      "- Implement automated tests in CI/CD pipeline with pre-submit and post-submit verification.",
      "- Use test doubles (mocks, stubs, fakes) to isolate units and improve test determinism.",
      "- Prefer hermetic tests that are self-contained and don't rely on external services.",
      "- Implement contract tests between services to ensure API compatibility.",
      "",
      "## **Tools & Frameworks**",
      "",
      "- For Python: Use pytest with pytest-cov for coverage reports.",
      "- For Go: Use the standard testing package with testify for assertions.",
      "- For TypeScript/JavaScript: Use Jest with ts-jest for type-checking during tests and Istanbul for coverage.",
      "- For load testing: Use tools like Locust or k6.",
      "- For API testing: Use Postman collections with Newman for automation.",
      "",
      "## **TypeScript Testing Best Practices**",
      "",
      "- Leverage TypeScript's type system for more robust tests.",
      "- Use interfaces for mocked dependencies to ensure type safety.",
      "- Implement proper typing for test fixtures and mock data.",
      "- Configure strict type-checking in tsconfig for test files.",
      "- Use type-safe assertions with libraries like ts-expect.",
      "",
      "## **Test Organization**",
      "",
      "- Co-locate tests with implementation code when possible.",
      "- Group tests by functionality rather than type.",
      "- Name test files with `_test` suffix (e.g., `payment_service_test.py`).",
      "- Structure test cases using the Arrange-Act-Assert pattern.",
      "- Implement test fixtures and factories to reduce test code duplication.",
      "",
      "## **Testing Data**",
      "",
      "- Use deterministic test data generators.",
      "- Avoid dependencies on production data for tests.",
      "- Create ephemeral test databases for integration tests.",
      "- Implement database migrations testing."
    ]
  },
  "Database Implementation": {
    "scope": "markdown",
    "prefix": "database-guide",
    "body": [
      "# Database Implementation",
      "",
      "Follow Google's best practices for database design and implementation:",
      "",
      "## **Database Selection**",
      "",
      "- Choose the right database type for specific workloads:",
      "  - **Relational (Cloud SQL)**: For transactional data with complex relationships.",
      "  - **NoSQL (Firestore)**: For semi-structured data with high read/write throughput.",
      "  - **In-memory (Memorystore)**: For caching and session data.",
      "  - **Time-series (BigTable)**: For metrics, logs, and IoT data.",
      "",
      "## **Relational Database Specific Guidance**",
      "",
      "### **PostgreSQL**",
      "",
      "- Leverage PostgreSQL's advanced features following Google Cloud SQL best practices:",
      "  - Use JSONB for flexible schema needs while maintaining query capabilities.",
      "  - Implement row-level security for multi-tenant applications.",
      "  - Utilize materialized views for complex reporting queries.",
      "  - Implement proper connection pooling (PgBouncer) for high-concurrency workloads.",
      "  - Use triggers and stored procedures judiciously and document thoroughly.",
      "",
      "### **MySQL**",
      "",
      "- Follow Google Cloud SQL for MySQL optimization practices:",
      "  - Use InnoDB as the default storage engine for ACID compliance.",
      "  - Implement proper indexing strategies (covering indexes, composite indexes).",
      "  - Configure connection pools properly to handle connection spikes.",
      "  - Use proper character sets (utf8mb4) and collations.",
      "  - Optimize table partitioning for large tables with historical data.",
      "",
      "### **SQLite**",
      "",
      "- Apply Google's guidelines for embedded databases:",
      "  - Use primarily for development, testing, and small-scale deployments.",
      "  - Implement proper locking strategies to avoid 'database is locked' errors.",
      "  - Keep database files on persistent storage with proper backup mechanisms.",
      "  - Use WAL (Write-Ahead Logging) mode for better concurrency.",
      "  - Monitor and vacuum databases regularly to maintain performance.",
      "",
      "## **Schema Design**",
      "",
      "- **Normalization**: Use appropriate normalization levels (typically 3NF for OLTP).",
      "- **Denormalization**: Apply strategic denormalization for read-intensive workloads.",
      "- **Indexing**: Create indexes for frequently queried fields but avoid over-indexing.",
      "- **Sharding**: Design sharding keys for horizontal scaling when necessary.",
      "- **Polymorphic Schemas**: Use table inheritance patterns for polymorphic data.",
      "",
      "## **Data Access Layer**",
      "",
      "- Implement a repository pattern to abstract database operations.",
      "- Use ORMs with performance considerations:",
      "  - **Python**: SQLAlchemy with connection pooling.",
      "  - **Go**: GORM or sqlx with prepared statements.",
      "  - **Node.js**: Prisma or TypeORM with connection management.",
      "- Parameterize queries to prevent SQL injection.",
      "- Implement connection pooling for efficient resource utilization.",
      "- Use transactions for maintaining data integrity.",
      "- Consider query builders for complex dynamic queries.",
      "",
      "## **Performance Optimization**",
      "",
      "- Implement query optimization with EXPLAIN plans.",
      "- Use appropriate caching strategies (query, result, object caches).",
      "- Monitor and optimize slow queries.",
      "- Implement database connection pooling.",
      "- Use asynchronous I/O for database operations when possible.",
      "- Follow Google Cloud recommended query performance practices.",
      "",
      "## **Scaling Strategies**",
      "",
      "- Implement read replicas for read-heavy workloads.",
      "- Use connection pooling for efficient resource utilization.",
      "- Consider database sharding for horizontal scaling.",
      "- Implement proper database partitioning strategies.",
      "- Follow Google's distributed database scaling patterns.",
      "",
      "## **Data Migration & Evolution**",
      "",
      "- Use migration tools for schema changes:",
      "  - **Python**: Alembic with SQLAlchemy.",
      "  - **Go**: golang-migrate or GORM migrations.",
      "  - **Node.js**: Prisma migrations or TypeORM migrations.",
      "- Implement versioned, reversible migrations.",
      "- Test migrations thoroughly before applying to production.",
      "- Have rollback strategies for failed migrations.",
      "- Follow Google's zero-downtime migration patterns.",
      "",
      "## **Security**",
      "",
      "- Use principle of least privilege for database access.",
      "- Encrypt sensitive data at rest and in transit.",
      "- Implement column-level encryption for PII data.",
      "- Use prepared statements to prevent SQL injection.",
      "- Implement comprehensive database auditing.",
      "- Follow Google Cloud Security Command Center recommendations.",
      "",
      "## **Resilience**",
      "",
      "- Implement automatic backups with point-in-time recovery.",
      "- Design for graceful degradation during database unavailability.",
      "- Use circuit breakers for database calls.",
      "- Implement retry mechanisms with exponential backoff.",
      "- Monitor database health and performance metrics.",
      "- Follow Google SRE practices for database reliability."
    ]
  },
  "Multi-Language Best Practices": {
    "scope": "markdown",
    "prefix": "multi-lang-guide",
    "body": [
      "# Multi-Language Best Practices",
      "",
      "Working across Flutter, FastAPI, Django REST, NestJS, React, and Angular involves consistent coding guidelines:",
      "",
      " - For Python code (FastAPI, Django), use `snake_case` for variables, `PascalCase` for classes, and 4-space indentation.",
      " - For JS/TS (NestJS, React, Angular), prefer `camelCase` for variables, 2-space indentation, and PascalCase for components/classes.",
      " - In Flutter (Dart), use `lowerCamelCase` for methods/variables, `UpperCamelCase` for classes.",
      " - Create environment-specific config files (e.g., dev, test, prod) to manage dependencies and credentials securely.",
      " - Use consistent commit message styles referencing tasks or issues (e.g., `fix:`, `feat:`).",
      " - Regularly review documentation and code styles to stay aligned with the evolving industry standards."
    ]
  },
  
  "GitHub Copilot Configuration": {
    "scope": "json",
    "prefix": "copilot-config",
    "body": [
      "{",
      "  \"github.copilot.chat.codeGeneration.useInstructionFiles\": true,",
      "",
      "  \"github.copilot.chat.commitMessageGeneration.instructions\": [",
      "    {",
      "      \"text\": \"Provide concise, descriptive commit messages highlighting file changes and reasons. Use emojis for clarity or emphasis when appropriate, but avoid excessive or irrelevant usage.\"",
      "    }",
      "  ]",
      "}"
    ]
  },

  "Reusable Flutter Best Practices": {
    "scope": "markdown",
    "prefix": "style-flutter",
    "body": [
      "## Flutter Development Best Practices",
      "",
      " - Use **Redux** for state management to maintain a predictable state flow.",
      " - API calls should be handled using **Dio** with interceptors for token refresh and logging.",
      " - Follow the **Clean Architecture** principle, separating UI, business logic, and data layers.",
      " - Use **MVVM (Model-View-ViewModel)** pattern for better separation of concerns.",
      " - Implement dependency injection using **GetIt** for better testability and flexibility.",
      " - Prefer **Flutter Lints** and follow effective Dart style guidelines.",
      " - Keep widgets small and reusable. Avoid putting business logic in UI components.",
      " - Use `FutureBuilder` and `StreamBuilder` wisely to manage async operations efficiently.",
      " - Persist local data using **Hive, SharedPreferences, or SQLite** based on use case.",
      " - Use environment variables (`.env`) for managing API keys and configurations."
    ]
  },

  "Reusable API Consumption": {
    "scope": "markdown",
    "prefix": "style-api",
    "body": [
      "## API Consumption with Dio",
      "",
      " - Use **Dio** for handling API requests with efficient error handling.",
      " - Implement **interceptors** for logging, authentication, and retry mechanisms.",
      " - Follow RESTful principles for structuring API calls.",
      " - Use **Response Models** (JSON serialization via `json_serializable`) for decoding API responses.",
      " - Implement global exception handling to catch API failures gracefully."
    ]
  },

  "Reusable State Management": {
    "scope": "markdown",
    "prefix": "style-state",
    "body": [
      "## State Management - Redux",
      "",
      " - Use **Redux** to manage the application's state in a predictable manner.",
      " - Structure state into reducers, actions, and middleware.",
      " - Keep reducers pure and avoid side effects inside reducers.",
      " - Use **Redux Middleware** for async tasks like API calls and authentication."
    ]
  },

  "Reusable Testing Standards": {
    "scope": "markdown",
    "prefix": "style-testing",
    "body": [
      "## Testing Standards for Flutter",
      "",
      " - Write unit tests for business logic using `flutter_test`.",
      " - Use `mockito` for mocking dependencies in unit tests.",
      " - Implement widget tests to verify UI behavior.",
      " - Use `integration_test` package for end-to-end testing of the app.",
      " - Follow Arrange-Act-Assert (AAA) pattern in tests."
    ]
  },

  "Reusable Security Best Practices": {
    "scope": "markdown",
    "prefix": "style-security",
    "body": [
      "## Security Best Practices",
      "",
      " - Secure API requests by adding token-based authentication.",
      " - Store sensitive data using **Flutter Secure Storage**.",
      " - Validate all user inputs to prevent injection attacks.",
      " - Use HTTPS for all API endpoints.",
      " - Implement rate limiting and request throttling where necessary."
    ]
  },

  "Reusable Optional Enterprise Best Practices": {
    "scope": "markdown",
    "prefix": "style-enterprise",
    "body": [
      "## Optional Enterprise Best Practices",
      "",
      "1. **Modular Architecture**: Structure the app into feature-based modules for scalability.",
      "2. **CI/CD**: Automate builds and testing using GitHub Actions or Bitrise.",
      "3. **Code Quality**: Enforce linting rules and maintain clean, maintainable code.",
      "4. **Performance Optimization**: Use Flutter DevTools for profiling and debugging.",
      "5. **Offline Support**: Implement local caching strategies with Hive or SQLite.",
      "6. **Internationalization**: Use `flutter_localizations` for multilingual support.",
      "7. **App Size Optimization**: Use `flutter build appbundle --split-debug-info`."
    ]
  },

  "API Design Copilot Guide": {
    "scope": "markdown",
    "prefix": "api-design-guide",
    "body": [
      "# API Design Copilot Guide",
      "",
      "This document provides guidelines for Copilot to follow during API implementation, ensuring consistency with Google's API design standards.",
      "",
      "## **Resource-Oriented Design**",
      "",
      "- **Resources (Nouns)**: Design APIs around resources (entities like `users`, `products`, `payments`).",
      "- **Collections (Plural)**: Use plural nouns for collections (e.g., `/v1/users`).",
      "- **Singular Instances**: Use resource identifiers for specific instances (e.g., `/v1/users/{userId}`).",
      "- **Sub-collections**: Represent relationships via nested resources (e.g., `/v1/users/{userId}/payments`).",
      "- **Standard Methods**: Map REST operations to standard methods (`list`, `get`, `create`, `update`, `delete`).",
      "",
      "## **HTTP Methods (Verbs)**",
      "",
      "- `GET`: Retrieve data (safe, idempotent) - Maps to `list` and `get` methods.",
      "- `POST`: Create new resources or execute custom actions.",
      "- `PUT`: Update entire resource (idempotent).",
      "- `PATCH`: Partially update a resource (idempotent with proper design).",
      "- `DELETE`: Remove a resource (idempotent).",
      "",
      "## **Versioning**",
      "",
      "- Include API version in the URL path (e.g., `/v1/users`).",
      "- Major versions only in path (e.g., `v1`, `v2`).",
      "- Minor changes should be backward compatible within the same major version.",
      "",
      "## **Query Parameters**",
      "",
      "- **Pagination**: Use `pageSize` and `pageToken` for cursor-based pagination.",
      "- **Filtering**: Use field_name-based filters (e.g., `?state=active`).",
      "- **Field Selection**: Use `fields` parameter to specify which fields to include.",
      "- **Sorting**: Use `orderBy` parameter (e.g., `?orderBy=name desc,created_at`).",
      "",
      "## **Response Formatting**",
      "",
      "- Return consistent JSON objects with standardized field naming.",
      "- Wrap list responses in a container object with metadata.",
      "- Use consistent field naming conventions (camelCase for JSON).",
      "- Include proper pagination tokens for list operations.",
      "",
      "## **Error Handling**",
      "",
      "Use appropriate HTTP status codes and consistent error response format:",
      "",
      "```json",
      "{",
      "  \"error\": {",
      "    \"code\": 400,",
      "    \"message\": \"Invalid resource name\",",
      "    \"status\": \"INVALID_ARGUMENT\",",
      "    \"details\": [...]",
      "  }",
      "}",
      "```",
      "",
      "Common status codes:",
      "",
      "- `200 OK`: Successful request.",
      "- `201 Created`: Resource created.",
      "- `204 No Content`: Request successful, no response body.",
      "- `400 Bad Request`: Invalid input.",
      "- `401 Unauthorized`: Authentication required.",
      "- `403 Forbidden`: Access denied.",
      "- `404 Not Found`: Resource not found.",
      "- `409 Conflict`: Request conflicts with current state.",
      "- `429 Too Many Requests`: Rate limit exceeded.",
      "- `500 Internal Server Error`: Unexpected server error.",
      "",
      "## **Security Best Practices**",
      "",
      "- **Authentication**: Implement OAuth 2.0, JWT or API keys.",
      "- **Authorization**: Use fine-grained access control with IAM-style permissions.",
      "- **HTTPS**: Use TLS for all API endpoints.",
      "- **Input Validation**: Strictly validate all inputs.",
      "- **Rate Limiting**: Implement per-user and per-IP request quotas.",
      "- **Auditing**: Log all API access for security monitoring.",
      "",
      "**By following Google's API design principles, APIs will be consistent, predictable, and easy to consume by developers.** 🚀",
      "",
      "All API functions must be documented with clear descriptions of parameters, return values, and examples. Follow Google API style guide for naming conventions and documentation. APIs should be backward compatible when possible, with proper deprecation procedures when breaking changes are necessary."
    ]
  },
  "Framework-Specific Guidelines": {
    "scope": "markdown",
    "prefix": "framework-specific-guide",
    "body": [
      "# Framework-Specific Guidelines",
      "",
      "## **Angular Guidelines**",
      "",
      "Based on Google's Angular style guide:",
      "",
      "- Use **NgRx** for state management in complex applications.",
      "- Follow the **container/presentational** component pattern.",
      "- Implement **lazy loading** for feature modules.",
      "- Use Angular's built-in **HttpInterceptor** for global request handling.",
      "- Create strongly typed interfaces for all API responses.",
      "- Implement data access through services, not components.",
      "- Follow OnPush change detection strategy for optimal performance.",
      "- Use Angular's built-in security features (e.g., DomSanitizer).",
      "",
      "### **Security Best Practices**",
      "",
      "- Implement proper XSRF/CSRF protection.",
      "- Sanitize all data displayed in templates.",
      "- Use Angular's built-in XSS protection.",
      "- Store sensitive data in secure storage services.",
      "- Validate all inputs on both client and server sides.",
      "",
      "## **Flutter Guidelines**",
      "",
      "- Follow Google's official Flutter style guide.",
      "- Use **MVVM** (Model-View-ViewModel) architecture pattern:",
      "  - **Model**: Data and business logic independent of UI",
      "  - **View**: UI elements (widgets) that observe ViewModels",
      "  - **ViewModel**: Manages UI state and business logic interactions",
      "- Implement proper separation of concerns between layers",
      "- Use state management solutions like Riverpod or GetX to support MVVM pattern",
      "- Create reactive bindings between View and ViewModel",
      "- Implement repository pattern for data sources",
      "- Use dependency injection for better testability",
      "- Create consistent widget themes and styling",
      "- Follow the **DRY** principle with reusable components",
      "",
      "### **Flutter MVVM Folder Structure**",
      "",
      "```",
      "lib/",
      "├── core/           # Core utilities and shared code",
      "├── data/           # Data sources, repositories, and models",
      "│   ├── models/     # Data models/entities",
      "│   ├── repositories/ # Repository implementations",
      "│   └── services/   # API clients and local data sources",
      "├── di/             # Dependency injection",
      "├── domain/         # Business logic and use cases",
      "│   ├── entities/   # Domain models",
      "│   └── usecases/   # Business logic use cases",
      "├── presentation/   # UI layer",
      "│   ├── common/     # Common widgets",
      "│   └── features/   # Feature-specific code",
      "│       └── feature_name/  # Specific feature",
      "│           ├── viewmodels/  # ViewModels for the feature",
      "│           └── views/     # UI components for the feature",
      "└── utils/          # Utility functions and extensions",
      "```",
      "",
      "### **Security Best Practices**",
      "",
      "- Store sensitive data with **flutter_secure_storage**.",
      "- Implement certificate pinning for API communications.",
      "- Use platform-specific security features (KeyStore/Keychain).",
      "- Never log sensitive information.",
      "- Implement proper app permissions handling.",
      "",
      "## **Python (FastAPI/Django) Guidelines**",
      "",
      "- Follow PEP 8 and Google's Python style guide.",
      "- Use dependency injection for better testability.",
      "- Create dedicated service layers between API and data access.",
      "- Use Pydantic models for request/response validation.",
      "- Implement proper exception handling and logging.",
      "- Use asynchronous patterns where appropriate.",
      "",
      "### **Security Best Practices**",
      "",
      "- Use parameterized queries to prevent SQL injection.",
      "- Implement proper rate limiting.",
      "- Use proper password hashing (Argon2, bcrypt).",
      "- Follow OWASP security guidelines.",
      "- Implement JWT token validation and refresh mechanisms.",
      "- Set security-focused HTTP headers.",
      "",
      "## **Go Guidelines**",
      "",
      "- Follow Google's official Go style guide.",
      "- Use context for cancellation and deadlines.",
      "- Follow standard project layout.",
      "- Create clear interfaces for service layers.",
      "- Use proper error handling with contextual information.",
      "- Implement graceful shutdowns.",
      "",
      "### **Security Best Practices**",
      "",
      "- Use proper input validation.",
      "- Implement secure random number generation.",
      "- Use Go's built-in security features.",
      "- Follow the principle of least privilege.",
      "- Implement proper TLS configuration.",
      "- Use secure dependencies and update regularly.",
      "",
      "## **React Guidelines**",
      "",
      "- Use functional components with hooks.",
      "- Implement proper state management (Redux, Context API).",
      "- Use TypeScript for type safety.",
      "- Follow component composition principles.",
      "- Create reusable custom hooks.",
      "- Use React.memo for performance optimization.",
      "",
      "### **Security Best Practices**",
      "",
      "- Sanitize data before rendering.",
      "- Use environment variables for configuration.",
      "- Implement proper authentication flow.",
      "- Use HTTPS for all API requests.",
      "- Avoid using dangerouslySetInnerHTML.",
      "- Regularly update dependencies to fix security vulnerabilities."
    ]
  },
  "Security Guide": {
    "scope": "markdown",
    "prefix": "security-guide",
    "body": [
      "# Security Guide",
      "",
      "Follow these security best practices across all applications based on Google's security standards:",
      "",
      "## **Authentication & Authorization**",
      "",
      "- Implement **OAuth 2.0** with OpenID Connect for authentication.",
      "- Use **JWT** with proper validation and short expiration times.",
      "- Implement **refresh token** rotation for improved security.",
      "- Use **multi-factor authentication** for sensitive operations.",
      "- Follow **role-based access control** (RBAC) or **attribute-based access control** (ABAC).",
      "- Store credentials securely using environment variables or secret management systems.",
      "",
      "## **Data Protection**",
      "",
      "- Encrypt sensitive data in transit and at rest.",
      "- Use **TLS 1.3** for all API communications.",
      "- Implement proper **key management** procedures.",
      "- Apply **field-level encryption** for sensitive data.",
      "- Use secure password storage with modern hashing algorithms (Argon2, bcrypt).",
      "- Implement **data masking** for logs and non-authorized views.",
      "",
      "## **API Security**",
      "",
      "- Implement proper **input validation** on all endpoints.",
      "- Use **rate limiting** to prevent abuse.",
      "- Set secure **HTTP headers** like:",
      "  - Content-Security-Policy",
      "  - X-Content-Type-Options",
      "  - X-Frame-Options",
      "  - Strict-Transport-Security",
      "- Validate all content types and reject unexpected formats.",
      "- Use **API gateways** for centralized security controls.",
      "",
      "## **Infrastructure Security**",
      "",
      "- Run containers with **non-root users**.",
      "- Use **vulnerability scanning** in CI/CD pipeline.",
      "- Apply **least privilege principle** for all service accounts.",
      "- Implement proper **secrets management** (e.g., Google Secret Manager).",
      "- Use **network segmentation** and proper firewall rules.",
      "- Implement **logging and monitoring** for security events.",
      "",
      "## **Mobile App Security**",
      "",
      "- Implement **certificate pinning** for API communications.",
      "- Use secure storage for sensitive data (Keychain/KeyStore).",
      "- Implement **root/jailbreak detection**.",
      "- Protect against **reverse engineering** and **repackaging**.",
      "- Apply proper **data encryption** for stored data.",
      "- Use secure **authentication methods** including biometrics when available."
    ]
  }
}
